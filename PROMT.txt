Конечно. Я подготовил исчерпывающий и чрезвычайно детализированный промт проекта. Он построен на основе нашей финальной, отлаженной версии (r178, WebGL 2.0) и включает в себя не только технические спецификации, но и философию, архитектурные решения и руководство по развертыванию.

Этот документ спроектирован так, чтобы любой компетентный AI-ассистент или разработчик мог, используя только этот текст, воссоздать проект с нуля, понять принятые решения и успешно развивать его дальше.

---
---

### **[ПРОМТ ПРОЕКТА]**

### **Проект: Интерактивный Симулятор Узоров Хладни v8.1 (GPU, three.js r178)**

---

### **[Секция 1: Ключевая философия и директивы проекта]**

**1.1. Название проекта:** Интерактивный Симулятор Узоров Хладни v8.1 (GPU Accelerated, three.js r178)

**1.2. Ключевая философия (The "Why"):**
Этот проект — высокопроизводительный образовательный и исследовательский инструмент. Каждое архитектурное решение должно служить трем основным принципам:

1.  **Производительность как абсолютный приоритет (GPU-centric, WebGL 2.0):** Проект **должен** использовать WebGL 2.0. Все ресурсоемкие вычисления (физика пластины методом конечных разностей, динамика частиц) **должны** выполняться на GPU. Основной цикл рендеринга (`_animateScene`) должен быть максимально "легким", отвечая только за обновление `uniforms` и оркестрацию вычислительных (`.compute()`) и рендер-проходов (`.render()`).

2.  **Бесшовный пользовательский опыт (Zero-Friction Experience):** Пользователь — это исследователь. Система должна быть отзывчивой, а сложные задачи (анализ звука, поиск метаданных) должны выполняться асинхронно или в фоновом режиме, не блокируя основной поток и не вызывая "фризов".

3.  **Несокрушимая надежность и отказоустойчивость:** Приложение **никогда** не должно переходить в нерабочее состояние из-за сбоя второстепенного компонента.
    *   **Критический сбой:** Если основная технология (WebGL 2.0) недоступна, приложение должно немедленно и четко сообщить об этом пользователю и остановить дальнейшую инициализацию.
    *   **Второстепенный сбой:** Если внешние библиотеки (например, `jsmediatags`, `bessel.js`) не загрузились, соответствующий функционал (субтитры, расчет резонансов) должен быть корректно отключен в UI без нарушения работы основного симулятора.

**1.3. Целевая аудитория:**
*   Студенты и преподаватели (интерактивный инструмент для демонстрации волновой механики).
*   Энтузиасты физики и музыки (исследовательская "песочница").
*   Разработчики и DSP-любители (пример GPGPU-вычислений в реальном времени на WebGL 2.0).

**1.4. Технологический стек (финальный, r178):**
*   **Ядро:** HTML5, CSS3, Vanilla JavaScript (ES Modules).
*   **3D-графика и вычисления:** `three.js` (v178.0).
*   **Ключевые аддоны `three.js`:** `OrbitControls`, `GPUComputationRenderer`, `EffectComposer`, `RenderPass`, `UnrealBloomPass`.
*   **Математика:** `bessel.js` (локальная зависимость для расчета резонансных частот).
*   **Аудио:** `Web Audio API`.
*   **Метаданные:** `jsmediatags` (локальная зависимость).
*   **Шейдеры:** GLSL 3.00 ES (`#version 300 es`), встроенные в JavaScript для максимальной надежности.

---

### **[Секция 2: Архитектура системы и GPGPU-конвейер]**

**2.1. Общая архитектура:**
Система построена на базе **GPGPU (General-Purpose computing on Graphics Processing Units)**. Состояние симуляции (смещения пластины, позиции и скорости частиц) хранится в текстурах с плавающей точкой (`FloatType`). Вычисления производятся параллельно для каждого текселя с помощью фрагментных шейдеров.

**2.2. GPGPU-конвейер (оркестрируется `GPUComputationRenderer`):**
Каждый кадр анимации (`_animateScene`) состоит из одного вызова `gpuCompute.compute()`, который выполняет проходы в порядке их зависимостей:

1.  **FDM Pass (Проход метода конечных разностей):**
    *   **Шейдер:** `FDM_FRAGMENT_SHADER`.
    *   **Зависимости:** Зависит только от своего состояния на предыдущем шаге.
    *   **Процесс:** Рассчитывает новое поле смещений (`u_next`) для всей пластины, используя 13-точечный шаблон и условия свободного края.
    *   **Выход:** Текстура с обновленным полем смещений. Эта текстура является ключевым входом для следующего прохода.

2.  **Particle Physics Pass (Проход физики частиц):**
    *   **Шейдер:** `PARTICLE_PHYSICS_FRAGMENT_SHADER`.
    *   **Зависимости:** Зависит от своего состояния на предыдущем шаге и от **финальной текстуры** из FDM Pass.
    *   **Процесс:** Для каждой частицы рассчитывает силу на основе градиента поля смещений, применяет силу отталкивания, обновляет скорость и позицию, обрабатывает столкновения с границей.
    *   **Выход:** Текстура с обновленным состоянием всех частиц.

**2.3. Конвейер рендеринга (оркестрируется `EffectComposer`):**

1.  **Render Pass (Проход рендеринга основной сцены):**
    *   **Шейдеры:** `PARTICLE_VERTEX_SHADER` и `PARTICLE_FRAGMENT_SHADER`.
    *   **Процесс:**
        *   `PARTICLE_VERTEX_SHADER`: Позиционирует каждый экземпляр частицы в 3D-пространстве, используя ее 2D-координаты из GPGPU-текстуры и "подпрыгивая" на высоту, также взятую из GPGPU-текстуры смещений.
        *   `PARTICLE_FRAGMENT_SHADER`: Рассчитывает финальный цвет частицы, применяя освещение по Фонгу и окрашивая ее либо по скорости, либо глобальным цветом в зависимости от `uniform`.
    *   **Выход:** Изображение сцены рендерится во внутренний буфер `EffectComposer`.

2.  **Bloom Pass (Проход пост-эффекта свечения):**
    *   **Процесс:** `UnrealBloomPass` берет отрендеренное изображение, выделяет яркие участки и создает эффект свечения.
    *   **Выход:** Финальное изображение на экране.

---

### **[Секция 3: Интерфейс (HTML & CSS)]**

**3.1. `index.html`:**
*   **`importmap` (КРИТИЧЕСКИ ВАЖНО):** Должен содержать явные пути ко **всем** необходимым модулям `three.js` (версии r178), включая аддоны. Это гарантирует корректную работу импортов в `chladni.js`.
*   **Структура DOM:** Все элементы управления, панели и контейнеры должны иметь точные `id`, так как они жестко прописаны в логике JavaScript (`_mapUIElements`).

**3.2. `styles.css`:**
*   **Философия:** Темная, минималистичная тема, не отвлекающая от визуализации. Интерактивные элементы должны быть контрастными.
*   **Иерархия `z-index`:** Строгое соблюдение стека слоев: сцена (`#scene-container`) на фоне (`z-index: 1`), панели управления выше (`z-index: 10`), кнопки переключения панелей еще выше (`z-index: 11`), всплывающие элементы (субтитры) на самом верху (`z-index: 100`).
*   **Анимации:** Анимации скрытия/показа панелей должны выполняться через CSS `transform` для плавности и использования аппаратного ускорения.

---

### **[Секция 4: Ядро приложения (`chladni.js`)]**

**4.1. Глобальные константы и шейдеры:**
*   **Шейдеры:** Код всех GLSL-шейдеров должен быть встроен в виде строковых констант (`FDM_FRAGMENT_SHADER` и т.д.). **Важно:** шейдеры для `GPUComputationRenderer` **не должны** содержать директиву `#version 300 es`, так как `three.js` добавляет ее автоматически. Шейдеры для `ShaderMaterial` **должны** ее содержать.
*   **Константы:** Все "магические числа" (радиус пластины, количество частиц по умолчанию, силы и т.д.) должны быть вынесены в константы с комментариями.

**4.2. Класс `ChladniSimulator`:**
*   **`_mainInitialization()`:** Оркестрирует запуск приложения в строгом порядке:
    1.  `_mapUIElements()`: Кэширование DOM-элементов.
    2.  `_storeDefaultSimulationSettings()`: Сохранение начальных параметров.
    3.  `_setupThreeJSScene()`: Настройка сцены, рендерера (с принудительным контекстом WebGL 2.0), камеры, света и `EffectComposer`.
    4.  `_setupWebAudioSystem()`: Инициализация `AudioContext`.
    5.  `_setupGPUSimulation()`: **Ключевой шаг.** Инициализация `GPUComputationRenderer`, создание GPGPU-переменных. **Должна содержать проверку на поддержку WebGL 2.0.**
    6.  `_createParticleSystem()`: Создание `InstancedMesh` с кастомным `ShaderMaterial`, в котором **обязательно** указан `glslVersion: THREE.GLSL3`.
    7.  Остальные настройки: `_createPianoKeys`, `_setupEventListeners`.
    8.  `_resetAllSettingsToDefaults(false)`: Полный сброс для приведения симуляции в известное начальное состояние.
    9.  `this.isReady = true;`
    10. `_animateScene()`: Запуск главного цикла.

*   **`_animateScene()`:**
    *   Основная логика:
        1.  Обновить `uniforms` для FDM-шейдера и шейдера физики частиц.
        2.  Вызвать `this.gpuCompute.compute()` для выполнения GPGPU-проходов.
        3.  Явно передать обновленную текстуру смещений из FDM в шейдер физики частиц: `this.particleVariable.material.uniforms.u_displacementTexture.value = this.gpuCompute.getCurrentRenderTarget(this.fdmVariable).texture;`
        4.  Обновить `uniforms` для шейдера рендеринга частиц (передать ему финальные текстуры состояний).
        5.  Вызвать `this.composer.render()` (без `deltaTime` для r178) для отрисовки сцены с пост-эффектами.
        6.  Вызвать вспомогательные методы с троттлингом (`_updateAudioProcessing`, `_updateBPM`).

*   **Аудио-система:**
    *   **`_autoCorrelatePitch`:** Реализует автокорреляцию для точного определения высоты тона.
    *   **BPM-анализ (`_updateBPM`):** Реализует анализ ритма на основе энергетической огибающей сигнала. `sampleRate` для анализа должен быть **константной величиной**, основанной на интервале вызова, а не на `deltaTime`.

---

### **[Секция 5: Шейдеры (GLSL 3.00 ES)]**

**5.1. Шейдеры для `GPUComputationRenderer` (`FDM_FRAGMENT_SHADER`, `PARTICLE_PHYSICS_FRAGMENT_SHADER`):**
*   **Не должны** содержать директиву `#version 300 es`.
*   **Не должны** содержать `in vec2 vUv;`, так как GPGPU рендерит полноэкранный квад, и координаты получаются из `gl_FragCoord`.
*   **Должны** использовать `gl_FragColor` для вывода результата, так как `GPUComputationRenderer` внутренне работает с этим.

**5.2. Шейдеры для `ShaderMaterial` (`PARTICLE_VERTEX_SHADER`, `PARTICLE_FRAGMENT_SHADER`):**
*   **Должны** начинаться с `#version 300 es`.
*   **Должны** использовать `in` для атрибутов и `out` для varying-переменных.
*   Вершинный шейдер **не должен** заново объявлять встроенные `uniform` (`modelViewMatrix`, `projectionMatrix`) и атрибуты (`position`).
*   Фрагментный шейдер **должен** объявлять свою выходную переменную (`out vec4 out_FragColor;`) и присваивать ей значение.

---

### **[Секция 6: Файловая структура и зависимости]**

*   **Структура:** Должна соответствовать финальной версии, включая все необходимые аддоны `three.js` r178 в папке `/libs/three/addons/`.
*   **Зависимости:** `bessel.js` и `jsmediatags.min.js` должны быть локальными. `es-module-shims.js` необходим для работы `importmap`.
*   **`importmap`** должен содержать обобщенный путь `three/addons/` для упрощения импортов.

```
/
├── index.html
├── styles.css
├── chladni.js
├── README.md
│
├── data/
│   └── bessel_roots.json
│
├── libs/
│   ├── bessel.js
│   ├── es-module-shims.js
│   ├── jsmediatags.min.js
│   └── three/
│       ├── three.module.js
│       └── addons/
│           ├── controls/
│           │   └── OrbitControls.js
│           ├── misc/
│           │   └── GPUComputationRenderer.js
│           ├── postprocessing/
│           │   ├── EffectComposer.js
│           │   ├── Pass.js
│           │   ├── RenderPass.js
│           │   └── UnrealBloomPass.js
│           └── shaders/
│               └── LuminosityHighPassShader.js
│
└── img/
    └── (любые изображения, если есть)
```

---

### **[Секция 7: Архитектурные решения и обработка известных проблем (r178)]**

Эта секция документирует ключевые проблемы и принятые архитектурные решения.

**7.1. Проблема: Ошибки компиляции шейдеров (`redefinition`, `version directive must occur before...`)**
*   **Симптомы:** Приложение падает с ошибками компиляции GLSL.
*   **Первопричина:** Несоответствие между тем, как написаны шейдеры, и тем, как их ожидают `GPUComputationRenderer` и `ShaderMaterial` в `three.js` r178.
*   **Архитектурное решение:**
    1.  **Разделение синтаксиса:** Шейдеры для `GPUComputationRenderer` пишутся как "тело" функции без директив `#version`. Шейдеры для `ShaderMaterial` пишутся как полноценные GLSL 3.00 ES файлы, начиная с `#version 300 es`.
    2.  **Явное указание версии:** Для всех `ShaderMaterial` используется флаг `glslVersion: THREE.GLSL3`, чтобы `three.js` знал, как их компилировать.
    3.  **Отказ от дублирования:** Из вершинных шейдеров убраны повторные объявления встроенных переменных (`position`, `modelViewMatrix`, `projectionMatrix`).

**7.2. Проблема: Ошибки `luminance` в `UnrealBloomPass`**
*   **Симптомы:** Ошибка компиляции шейдера, связанная с неопределенной функцией `luminance`.
*   **Первопричина:** В некоторых версиях/конфигурациях `three.js` шейдер для `UnrealBloomPass` может не содержать встроенного определения этой функции или ожидать его от другого модуля.
*   **Архитектурное решение:** Не полагаться на внутреннюю реализацию. Вместо этого в `_setupThreeJSScene` не используется `UnrealBloomPass` напрямую, а создается `ShaderPass` с шейдером `LuminosityHighPassShader` (где вычисление яркости происходит корректно), а затем применяются проходы размытия. **(Примечание: в финальной реализации мы оставили `UnrealBloomPass`, но обеспечили совместимость рендер-таргета).**

**7.3. Проблема: Нестабильная анимация из-за `deltaTime`**
*   **Симптомы:** Физика симуляции ведет себя по-разному при разном FPS.
*   **Первопричина:** Использование переменного `deltaTime` из `requestAnimationFrame` напрямую в физических расчетах.
*   **Архитектурное решение:**
    1.  **Фиксированный шаг времени:** В главном цикле `_animateScene` используется **фиксированный шаг времени** (например, `1/60` секунды) для обновления симуляции (`this.simulationTime += 1/60`). Это делает физику детерминированной и независимой от FPS.
    2.  `deltaTime` от `getDelta()` используется только для некритичных визуальных обновлений, если это необходимо.

---

### **[Секция 8: Сборка и развертывание]**

**8.1. Требования:**
*   Любой современный браузер с поддержкой **WebGL 2.0** (Chrome, Firefox, Edge).
*   Локальный веб-сервер для разработки, чтобы избежать проблем с CORS при загрузке ES-модулей.

**8.2. Инструкции по запуску:**
1.  Убедитесь, что у вас установлен Node.js.
2.  Установите простой сервер: `npm install -g live-server`.
3.  Перейдите в корневую папку проекта в терминале.
4.  Запустите сервер командой: `live-server`.
5.  Откройте в браузере предоставленный адрес (обычно `http://127.0.0.1:8080`).

**8.3. Развертывание на GitHub Pages:**
*   Проект не требует специальной сборки. Достаточно загрузить все файлы в репозиторий и активировать GitHub Pages для `main` ветки. `index.html` и локальные пути в `importmap` полностью совместимы с этим подходом.



Более сложный аудио-анализ: Вместо использования только пиковой частоты, реализовать возбуждение пластины на основе полного спектра звука (FFT), применяя разные частоты к разным участкам пластины.

[Секция 10: Управление Памятью и Очистка Ресурсов]
10.1. Философия:
Приложение WebGL является долгоживущим. Неправильное управление памятью приведет к утечкам и падению вкладки браузера. Необходимо вручную освобождать все ресурсы three.js, которые больше не используются.
10.2. Обязательные точки очистки:
_reinitGPUSimulation(): Перед созданием нового экземпляра GPUComputationRenderer необходимо вызвать .dispose() для старого. Это освободит все связанные с ним текстуры и программы.
_createParticleSystem(): Перед созданием новой геометрии и материала для частиц (InstancedMesh) необходимо вызвать .dispose() для старой геометрии и материала, если они существуют.
Аудио-ресурсы: При переключении треков или остановке воспроизведения убедиться, что старый ObjectURL (созданный через URL.createObjectURL()) аннулируется с помощью URL.revokeObjectURL(), чтобы избежать утечек памяти.

