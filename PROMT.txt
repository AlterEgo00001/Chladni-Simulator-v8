

### **[ПРОМТ ПРОЕКТА]**

### **Проект: Интерактивный Симулятор Узоров Хладни v9.0 (GPU, WebGL 2.0, three.js r178)**

---

### **[Секция 1: Ключевая философия и директивы проекта]**

**1.1. Название проекта:** Интерактивный Симулятор Узоров Хладни v9.0 (GPU Accelerated, three.js r178)

**1.2. Ключевая философия (The "Why"):**
Этот проект — высокопроизводительный образовательный и исследовательский инструмент. Каждое архитектурное решение должно служить трем основным принципам:

1.  **Производительность как абсолютный приоритет (GPU-centric, WebGL 2.0):** Проект **должен** использовать WebGL 2.0 для доступа к современным возможностям GPU. Все ресурсоемкие вычисления (физика пластины, динамика частиц) **должны** выполняться на GPU. Основной цикл рендеринга (`_animateScene`) должен быть максимально "легким", отвечая только за обновление `uniforms` и оркестрацию вычислительных (`.compute()`) и рендер-проходов (`.render()`).

2.  **Детерминизм и предсказуемость:** Физика симуляции **должна** быть детерминированной и не зависеть от производительности клиентской машины (FPS). Это достигается использованием **фиксированного шага времени** для всех физических расчетов.

3.  **Несокрушимая надежность и отказоустойчивость:** Приложение **никогда** не должно переходить в нерабочее состояние из-за сбоя второстепенного компонента.
    *   **Критический сбой:** Если основная технология (WebGL 2.0) недоступна, приложение должно немедленно и четко сообщить об этом пользователю и полностью остановить дальнейшую инициализацию, чтобы избежать каскадных ошибок.
    *   **Второстепенный сбой:** Если внешние библиотеки (например, `jsmediatags`, `bessel.js`) не загрузились, соответствующий функционал (субтитры, расчет резонансов) должен быть корректно отключен в UI без нарушения работы основного симулятора.

**1.3. Целевая аудитория:**
*   Студенты и преподаватели (интерактивный инструмент для демонстрации волновой механики).
*   Энтузиасты физики и музыки (исследовательская "песочница").
*   Разработчики и DSP-любители (пример GPGPU-вычислений в реальном времени на WebGL 2.0).

**1.4. Технологический стек (финальный, r178):**
*   **Ядро:** HTML5, CSS3, Vanilla JavaScript (ES Modules).
*   **3D-графика и вычисления:** `three.js` (v178.0).
*   **Ключевые аддоны `three.js`:** `OrbitControls`, `GPUComputationRenderer`, `EffectComposer`, `RenderPass`, `UnrealBloomPass`.
*   **Математика:** `bessel.js` (локальная зависимость для расчета резонансных частот).
*   **Аудио:** `Web Audio API`.
*   **Метаданные:** `jsmediatags` (локальная зависимость).
*   **Шейдеры:** **GLSL 3.00 ES**, встроенные в JavaScript для максимальной надежности.

---

### **[Секция 2: Архитектура системы и GPGPU-конвейер]**

**2.1. Хранение состояния (State Storage):**
Система построена на базе **GPGPU**. Состояние симуляции (смещения пластины, позиции и скорости частиц) хранится в текстурах с плавающей точкой (`FloatType`). Вычисления производятся параллельно для каждого текселя с помощью фрагментных шейдеров.

**2.2. GPGPU-конвейер (оркестрируется `GPUComputationRenderer`):**
Каждый кадр анимации (`_animateScene`) состоит из одного вызова `gpuCompute.compute()`. Зависимости между переменными настроены так, чтобы обеспечить строгий порядок выполнения:

1.  **FDM Pass (Проход метода конечных разностей):**
    *   **Шейдер:** `FDM_FRAGMENT_SHADER`.
    *   **Зависимости:** `fdmVariable` зависит только от самой себя (`[this.fdmVariable]`).
    *   **Процесс:** Рассчитывает новое поле смещений (`u_next`) для всей пластины.
    *   **Выход:** Обновленная текстура состояния FDM.

2.  **Particle Physics Pass (Проход физики частиц):**
    *   **Шейдер:** `PARTICLE_PHYSICS_FRAGMENT_SHADER`.
    *   **Зависимости:** `particleVariable` зависит от себя и от `fdmVariable` (`[this.particleVariable, this.fdmVariable]`).
    *   **Процесс:** Для каждой частицы рассчитывает силу на основе **финального** градиента поля смещений из FDM Pass, обновляет ее состояние.
    *   **Выход:** Обновленная текстура состояния частиц.

**2.3. Конвейер рендеринга (оркестрируется `EffectComposer`):**

1.  **Render Pass (Проход рендеринга основной сцены):**
    *   **Шейдеры:** `PARTICLE_VERTEX_SHADER` и `PARTICLE_FRAGMENT_SHADER`, обернутые в `ShaderMaterial` с флагом `glslVersion: THREE.GLSL3`.
    *   **Процесс:** Рендерит `InstancedMesh` частиц, позиционируя их на основе данных из GPGPU-текстур.
    *   **Выход:** Изображение сцены рендерится во внутренний буфер `EffectComposer`.

2.  **Bloom Pass (Проход пост-эффекта свечения):**
    *   **Процесс:** `UnrealBloomPass` создает эффект свечения. Для совместимости с WebGL 2.0 и GPGPU, `EffectComposer` инициализируется с `WebGLRenderTarget`, использующим `HalfFloatType`.
    *   **Выход:** Финальное изображение на экране.

---

### **[Секция 3: Интерфейс (HTML & CSS)]**

**3.1. `index.html`:**
*   **`importmap`:** Должен содержать явные пути ко **всем** модулям `three.js` r178. Обязательно должен быть общий путь `three/addons/` для упрощения импортов.
*   **Структура DOM:** Все элементы управления должны иметь точные `id`.

**3.2. `styles.css`:**
*   **Философия:** Темная, минималистичная, функциональная тема.
*   **Иерархия `z-index`:** Строгое соблюдение стека слоев: сцена (`z-index: 1`), панели управления (`z-index: 10`), всплывающие элементы (`z-index: 100`).
*   **Анимации:** Анимации скрытия/показа панелей должны выполняться через CSS `transform`.

---

### **[Секция 4: Ядро приложения (`chladni.js`)]**

**4.1. `_mainInitialization()`: Порядок священен**
Оркестровка запуска должна происходить в строгом порядке, чтобы избежать гонок состояний:
1.  **`_mapUIElements()`**: Кэширование DOM-элементов.
2.  **`_storeDefaultSimulationSettings()`**: Кэширование начальных параметров.
3.  **`_setupThreeJSScene()`**: Настройка сцены. **Ключевой момент:** рендерер должен создаваться с принудительным контекстом WebGL 2.0.
4.  **`_setupWebAudioSystem()`**: Инициализация `AudioContext`.
5.  **`_setupGPUSimulation()`**: Настройка `GPUComputationRenderer`. Содержит проверку на WebGL 2.0.
6.  **`_createParticleSystem()`**: Создание `InstancedMesh` с `ShaderMaterial` (`glslVersion: THREE.GLSL3`).
7.  **`_setupEventListeners()`**: Навешивание обработчиков событий.
8.  **`_resetAllSettingsToDefaults(false)`**: Полный сброс для приведения системы в известное начальное состояние.
9.  `this.isReady = true;`
10. **`_animateScene()`**: Запуск главного цикла.

**4.2. `_animateScene()`: Сердце приложения**
*   **Фиксированный шаг времени:** Для детерминизма физики, `this.simulationTime` должен инкрементироваться на константу (например, `1/60`), а не на плавающий `deltaTime`.
*   **Порядок операций:**
    1.  Обновить `uniforms` для всех GPGPU-шейдеров.
    2.  Явно передать обновленную текстуру смещений из FDM в шейдер физики частиц: `this.particleVariable.material.uniforms.u_displacementTexture.value = this.gpuCompute.getCurrentRenderTarget(this.fdmVariable).texture;`.
    3.  Вызвать `this.gpuCompute.compute()` **один раз**.
    4.  Обновить `uniforms` для рендер-шейдера частиц.
    5.  Вызвать `this.composer.render()` (без `deltaTime` для r178).
    6.  Вызвать вспомогательные методы с троттлингом.

---

### **[Секция 5: Шейдеры (GLSL 3.00 ES) — Строгие правила]**

**5.1. Правила для шейдеров `GPUComputationRenderer`:**
*   **Не должны** содержать директиву `#version 300 es`.
*   **Не должны** содержать `in vec2 vUv;`. Координаты получаются из `gl_FragCoord`.
*   **Должны** использовать `gl_FragColor` для вывода, так как это ожидается внутренним устройством `GPUComputationRenderer`.
*   **Не должны** дублировать `uniform`, которые `GPUComputationRenderer` предоставляет сам (`resolution`).

**5.2. Правила для шейдеров `ShaderMaterial`:**
*   **Должны** начинаться с `#version 300 es`.
*   **Должны** использовать `in` для атрибутов и `out` для varying-переменных.
*   **Не должны** заново объявлять встроенные переменные (`position`, `modelViewMatrix`, `projectionMatrix`).
*   Фрагментный шейдер **должен** объявлять `out vec4 out_FragColor;` и присваивать ей значение.
*   В JavaScript-конструкторе `ShaderMaterial` **обязательно** должен быть указан флаг `glslVersion: THREE.GLSL3`.

---

### **[Секция 6: Файловая структура и зависимости]**

(Содержимое идентично вашему, так как оно корректно)

---

### **[Секция 7: Архитектурные решения и обработка известных проблем (r178)]**

**7.1. Проблема: Ошибки компиляции шейдеров (`redefinition`, `version directive...`)**
*   **Первопричина:** Конфликт между "сырым" GLSL 3.0 кодом и ожиданиями `GPUComputationRenderer` и `ShaderMaterial` в `three.js`.
*   **Архитектурное решение:**
    1.  **Разделение синтаксиса:** Строгое следование правилам из Секции 5. GPGPU-шейдеры пишутся как "тело" без `#version`. Рендер-шейдеры — как полноценные GLSL 3.0 файлы.
    2.  **Явное указание версии:** Для всех `ShaderMaterial` используется флаг `glslVersion: THREE.GLSL3`.
    3.  **Отказ от дублирования:** Из вершинных шейдеров убраны повторные объявления встроенных `uniform` и `attribute`.

**7.2. Проблема: Ошибки `luminance` и артефакты в `UnrealBloomPass`**
*   **Первопричина:** Несовместимость форматов текстур и настроек фильтрации между GPGPU-вычислениями (требующими `NearestFilter`) и пост-эффектами (требующими `LinearFilter`).
*   **Архитектурное решение:** Инициализировать `EffectComposer` с собственным `WebGLRenderTarget`, который явно использует `HalfFloatType` и `LinearFilter`. Это изолирует пост-эффекты от настроек `GPUComputationRenderer` и обеспечивает их корректную работу.

**7.3. Проблема: Нестабильная, зависящая от FPS физика**
*   **Первопричина:** Использование переменного `deltaTime` напрямую в физических расчетах.
*   **Архитектурное решение:**
    1.  **Фиксированный шаг времени:** В `_animateScene` используется **фиксированный шаг** (`1/60`) для обновления симуляции. Это делает физику детерминированной.
    2.  `deltaTime`, полученный от `clock.getDelta()`, игнорируется для физики.

---

### **[Секция 8: Управление Памятью и Очистка Ресурсов]**

**8.1. Философия:**
Приложение WebGL является долгоживущим. Неправильное управление памятью приведет к утечкам и падению вкладки браузера. Необходимо вручную освобождать все ресурсы `three.js`, которые больше не используются.

**8.2. Обязательные точки очистки:**
*   **`_reinitGPUSimulation()`:** Перед созданием нового экземпляра `GPUComputationRenderer` необходимо вызвать `.dispose()` для старого. Это освободит все связанные с ним текстуры и шейдерные программы.
*   **`_createParticleSystem()`:** Перед созданием новой геометрии и материала для частиц (`InstancedMesh`) необходимо вызвать `.dispose()` для старой геометрии и материала, если они существуют.
*   **Аудио-ресурсы:** При переключении треков или остановке воспроизведения убедиться, что старый `ObjectURL` (созданный через `URL.createObjectURL()`) аннулируется с помощью `URL.revokeObjectURL()`, чтобы избежать утечек памяти в браузере.
*   **Обработчики событий:** При полном уничтожении симулятора (если бы такая логика была), все `EventListeners` должны быть удалены.

---

### **[Секция 9: Сборка и развертывание]**

(Содержимое идентично вашему, так как оно корректно)

---

### **[Секция 10: Потенциальные улучшения и направления для развития]**

Этот раздел служит руководством для будущих разработчиков по расширению функционала проекта.

*   **Расширение аудио-анализа:**
    *   Вместо использования только одной пиковой частоты, реализовать возбуждение пластины на основе полного спектра звука (FFT). Например, низкие частоты воздействуют на центр, высокие — на края.
    *   Добавить анализ транзиентов (резких атак) для "встряхивания" частиц.

*   **UI/UX:**
    *   Сохранение и загрузка пользовательских пресетов (параметров физики и визуализации) в `localStorage`.
    *   Более продвинутый плейлист для аудиофайлов.
